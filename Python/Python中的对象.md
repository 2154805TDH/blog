# Python 中的对象

Python 中一切皆对象：python 中的函数和类均属于一等公民

python 中所有的类对象是 object 的实例，object 类继承之 type 类。

Python 中变量无类型，对象有类型，当一个变量没有被赋值就被使用时，那么 Python 认为这个变量没有定义。

python 中 调用函数并传值时，传入的使变量所引用的值的地址，及浅拷贝。

浅拷贝和深拷贝：

> python 中变量存在栈中，变量所引用的值存放在堆中，python 在创建值、拷贝值时，是将值对应的地址传给变量。拷贝不可变值时，直接将值对应的地址赋给变量，效果和深拷贝效果一样；浅拷贝列表等可变值时，由于也是传递的值的地址，当新的变量修改了值的时候会将旧变量跟着改变，要消除这个影响。需要使用 copy 模块中的 deepcopy。深拷贝将会在堆中申请一个新的地址用于存放值的完整备份，然后将这新的地址传递给变量。

> 声明一个 tlist，拷贝 tlist 给 alist，对 alist 追加一个值，打印这两列表可以看到两个列表的值均改变。

```ipython
In [1]: tlist=[1,2,3]

In [2]: alist=tlist

In [3]: alist.append(4)

In [4]: print(tlist)
[1, 2, 3, 4]

In [5]: print(alist)
[1, 2, 3, 4]
```

讲到 python 中地址，就要讲到 Python 中`==`和`is`的关系了：

> 将上面的 tlist 值深拷贝至 alist，然后分别比较两个值，可以看到`==`只判断两个变量是否值相等，`is`判断两个变量是否为同一`id()`返回值。

```ipython
In [6]:  print(tlist==alist)
True

In [7]:  print(alist is tlist)
True

In [8]: import copy

In [9]: alist=copy.deepcopy(tlist)

In [10]: print(tlist==alist)
True

In [11]: print(alist is tlist)
False
```

python 中垃圾回收：

> 引用计数机制为主，分代收集机制为辅的策略。

1. 垃圾回收
   1. 小整数[-5,256]共用对象，常驻内存。
   2. 单个字符共用对象，常驻内存。
   3. 单个单词，不可修改，默认开启 intern 机制，共用对象，引用计数为 0 时销毁。
   4. 字符串（含有空格），不可修改，没开启 intern 机制，不共用对象，引用计数为 0 时销毁。
   5. 大整数不共用内存，引用计数为 0 时销毁。
   6. 数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象。
2. 循环引用

   好处：

   &nbsp;&nbsp;&nbsp;&nbsp;简单

   &nbsp;&nbsp;&nbsp;&nbsp;实时性：一旦没有引用，内存就直接释放了，处理回收内存的时间分摊到了平时。

   坏处：

   &nbsp;&nbsp;&nbsp;&nbsp;维护引用计数消耗资源。

   &nbsp;&nbsp;&nbsp;&nbsp;循环引用带来的问题，没有解决。

3. 分代收集垃圾机制

   空间换时间的策略。存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。
